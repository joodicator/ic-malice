-- Functionality to subject Alice programs to static type checking and
-- semantic analysis.
--------------------------------------------------------------------------------

module AliceChecker where

import Control.Monad
import Control.Monad.Instances
import Data.List

import AliceAST

--------------------------------------------------------------------------------
-- The representation of a binding from a name to an entity in the program.
-- A binding of the form ("$", BStmt decl) represents an enclosing block scope.
type Bind
  = (ID, BindTarget)

--------------------------------------------------------------------------------
-- The entity referred to by a binding.
data BindTarget
  = BStmt   !Stmt       -- The declaration of a symbol.
  | BParam  !Param      -- An enclosing formal parameter.
  deriving (Eq, Show)

--------------------------------------------------------------------------------
-- Given the sequence of statements forming an Alice program, returns Right ()
-- if it is semantically valid or otherwise an error message.
checkAlice :: [Stmt] -> Either String ()
checkAlice stmts = do
    (binds, execs) <- checkStmts stmts [] []
    case lookup "hatta" binds of
      Just (BStmt stmt@SSubDec{ sDParams=params }) -> do
        unless (null params) $ stmtError stmt $
            "the top-level procedure " ++ show "hatta" ++ " may not take "
            ++ "any arguments"
      _ -> do
        aliceError $ "the top-level procedure " ++ show "hatta" ++ " is missing"

--------------------------------------------------------------------------------
-- Checks the validity of the enclosing scope generated by a statement with a 
-- body of sub-statements (a function, subroutine or anonymous block) in the
-- context of the given external and internal bindings.
checkClosure :: Stmt -> [Bind] -> [Bind] -> Either String ()
checkClosure stmt locals globals = do
    (binds, execs) <- checkStmts (sBody stmt) locals globals
    when (not (null binds) && null execs) $ stmtError stmt $
        "block contains declarations but no executable code"
 
--------------------------------------------------------------------------------
-- Verifies that the given sequence of statements consists of a sequence of
-- declarations followed by a sequence of executable statements, and that the
-- statements are valid in the context of the given bindings.
checkStmts :: [Stmt]                    -- Input
           -> [Bind]                    -- Initial local bindings
           -> [Bind]                    -- Global bindings
           -> Either String ([Bind],    -- Resulting local bindings
                             [Stmt])    -- Executable subsequence
checkStmts [] locals globals
  = return (locals, [])
checkStmts (stmt : stmts) locals globals
  = case isDecl stmt of
      True -> do
        checkDecls (stmt : stmts) locals globals
      False -> do
        checkExecs (stmt : stmts) (locals ++ globals)
        return (locals, stmt : stmts)

--------------------------------------------------------------------------------
-- A special case of checkStmts when the first statement is a declaration.
checkDecls :: [Stmt] -> [Bind] -> [Bind] -> Either String ([Bind], [Stmt])
checkDecls (stmt : stmts) locals globals = do
    let name = sID stmt
    case lookup name locals of
      Nothing -> do
        let locals' = (name, BStmt stmt) : locals
        checkStmt stmt (locals' ++ globals)        
        checkStmts stmts locals' globals
      _ -> do
        stmtError stmt $ show name ++ " was previously declared in this scope"

--------------------------------------------------------------------------------
-- Checks that an executable subsequence of statements as returned by checkStmts
-- is valid in the context of the given bindings.
checkExecs :: [Stmt] -> [Bind] -> Either String ()
checkExecs stmts binds = do
    let parent = lookup "$" binds
    when (not (null stmts) && parent == Nothing) $
        stmtError (head stmts) $
            "executable statements are not permitted at the top level"
    forM_ stmts $ \stmt -> do
        when (isDecl stmt) $ stmtError stmt $
            "declarations are not permitted after executable statements"
        checkStmt stmt binds

--------------------------------------------------------------------------------
-- Checks that the given statement is consistent with the type system and with
-- the given enclosing bindings.
checkStmt :: Stmt -> [Bind] -> Either String ()

-- Variable declaration with initialiser
checkStmt stmt@SVarDec{ sInit=Just init, sID=id, sType=dType } binds = do
    iType <- checkExpr init binds stmt
    unless (iType == dType) $ stmtError stmt $
        "in declaration of variable " ++ show id ++ ", initialiser type of '"
        ++ show iType ++ "' does not match declared type of '" ++ show dType
        ++ "'"

-- Variable declaration without initialiser
checkStmt stmt@SVarDec { sInit=Nothing } binds = do
    return ()

-- Array declaration
checkStmt stmt@SArrDec{ sID=id, sSize=size } binds = do
    sType <- checkExpr size binds stmt
    unless (sType == TyNumber) $ stmtError stmt $
        "in declaration of array " ++ show id ++ ", size type is '"
        ++ show sType ++ "', where " ++ show TyNumber ++ " is expected"

-- Function declaration
checkStmt stmt@SFunDec{ } binds = do
    checkParamClosure stmt binds

-- Subroutine declaration
checkStmt stmt@SSubDec{ } binds = do
    checkParamClosure stmt binds

-- Branching structure
checkStmt stmt@SBranch{ sBranches=branches } binds = do
    forM_ branches $ \(guard, body) -> do
         checkGuarded stmt guard body binds

-- Looping structure
checkStmt stmt@SWhile{ sGuard=guard, sBody=body } binds = do
    checkGuarded stmt guard body binds

-- Anonymous block structure
checkStmt stmt@SBlock{ } binds = do
    checkClosure stmt [] binds

-- Subprocedure call
checkStmt stmt@SCall{ sID=id, sCParams=cParams } binds = do
    case lookup id binds of
      Just (BStmt SSubDec{ sDParams=dParams }) -> do
        checkSubFunCall cParams dParams binds stmt id
      _ -> do
        stmtError stmt $
            "the name " ++ show id ++ " is not bound to a subprocedure"

-- Return statement
checkStmt stmt@SReturn{ sSource=expr } binds = do
    case lookup "$" binds of
      Just (BStmt SFunDec{ sID=id, sType=dType }) -> do
        eType <- checkExpr expr binds stmt
        unless (eType == dType) $ stmtError stmt $
            "the return value has type '" ++ show eType ++ "', where the "
            ++ "return type of " ++ show id ++ " is '" ++ show dType ++ "'"
      _ -> do
        stmtError stmt $
            "return statement outside of a directly enclosing function"

-- Assignment statement
checkStmt stmt@SAssign{ sTarget=target, sSource=source } binds = do
    unless (isLValue target) $ stmtError stmt $
        "illegal left-hand side form in assignment statement"
    tType <- checkExpr target binds stmt
    sType <- checkExpr source binds stmt
    unless (tType == sType) $ stmtError stmt $
        "left-hand side of assignment statement has type '" ++ show tType
        ++ "', which differs from the right-hand side's type of '" ++ show sType
        ++ "'"

-- Increment statement
checkStmt stmt@SInc{ sTarget=target } binds = do
    unless (isLValue target) $ stmtError stmt $
        "illegal operand form in increment statement"
    tType <- checkExpr target binds stmt
    unless (tType `elem` [TyNumber]) $ stmtError stmt $
        "operand of increment statement has illegal type '" ++ show tType ++ "'"

-- Decrement statement
checkStmt stmt@SDec{ sTarget=target } binds = do
    unless (isLValue target) $ stmtError stmt $ 
        "illegal operand form in decrement statement"
    tType <- checkExpr target binds stmt
    unless (tType `elem` [TyNumber]) $ stmtError stmt $
        "operand of decrement statement has illegal type '" ++ show tType ++ "'"

-- Input statement
checkStmt stmt@SRead{ sTarget=target } binds = do
    unless (isLValue target) $ stmtError stmt $
        "illegal operand form in read statement"
    void $ checkExpr target binds stmt

-- Output statement
checkStmt stmt@SWrite{ sSource=source } binds = do
    void $ checkExpr source binds stmt

--------------------------------------------------------------------------------
-- Checks the validity of the enclosing scope generated by a statement with a 
-- list of formal parameters (a function or a subroutine) in the context of the
-- given external bindings.
checkParamClosure :: Stmt -> [Bind] -> Either String ()
checkParamClosure stmt globals = do
    let params = sDParams stmt
    let names = map fst params
    let dupes = names \\ nub names
    unless (null dupes) $ stmtError stmt $
        "the formal parameter name " ++ show (head dupes) ++ " occurs multiply"
    let locals = zip names (map BParam params) ++ [("$", BStmt stmt)]
    checkClosure stmt locals globals

--------------------------------------------------------------------------------
-- Checks that a sequence of statements guarded by a boolean expression, but
-- not within an enclosing scope, are valid.
checkGuarded :: Stmt -> Expr -> [Stmt] -> [Bind] -> Either String ()
checkGuarded stmt guard body binds = do
    gType <- checkExpr guard binds stmt
    unless (gType == TyBoolean) $ stmtError stmt $
       "the guard expression has type '" ++ show gType ++ "', where '"
       ++ show TyBoolean ++ "' is expected"
    checkExecs body binds

--------------------------------------------------------------------------------
-- Checks the validity of an actual call to a subroutine or function.
checkSubFunCall :: [Expr]               -- Actual parameters.
                -> [Param]              -- Formal parameters.
                -> [Bind]               -- Enclosing bindings.
                -> Stmt                 -- The statement containing the caller.
                -> ID                   -- The name of the callee.
                -> Either String ()
checkSubFunCall cParams dParams binds stmt id = do
    let (cLen, dLen) = (length cParams, length dParams)
    unless (length cParams == length dParams) $ stmtError stmt $
        "in the call to " ++ show id ++ ", " ++ show cLen
        ++ " parameters are given, but " ++ show dLen ++ " are expected"
    forM_ (zip cParams dParams) $ \(cExpr, (dName, dType)) -> do
        cType <- checkExpr cExpr binds stmt
        unless (cType == dType) $ stmtError stmt $
            "in the call to " ++ show id ++ ", the parameter " ++ show dName
            ++ " is given with type '" ++ show cType ++ "', but '" ++ show dType
            ++ "' is expected"

--------------------------------------------------------------------------------
-- Returns the type of the given expression, iff it is valid.
checkExpr :: Expr
          -> [Bind]                 -- Enclosing bindings.
          -> Stmt                   -- Containing statement.
          -> Either String Type

-- Number literal
checkExpr (ENumber _) binds stmt = do
    return TyNumber

-- Letter literal
checkExpr (ELetter _) binds stmt = do
    return TyLetter

-- Sentence literal
checkExpr (ESentence _) binds stmt = do
    return TySentence

-- Variable
checkExpr (EVariable id) binds stmt = do
    case lookup id binds of
      Just (BParam (_, pType)) -> do
        return pType
      Just (BStmt SVarDec{ sType=vType }) -> do
        return vType
      Just (BStmt SArrDec{ sType=vType }) -> do
        return $ TyArray vType
      _ -> do
        stmtError stmt $
            "the name " ++ show id ++ " is not bound to a variable"

-- Function call
checkExpr (EFunCall id cParams) binds stmt = do
    case lookup id binds of
      Just (BStmt SFunDec{ sDParams=dParams, sType=dType }) -> do
        checkSubFunCall cParams dParams binds stmt id
        return dType
      _ -> do
        stmtError stmt $
            "the name " ++ show id ++ " is not bound to a function"

-- Array subscript
checkExpr (EArrElt id elt) binds stmt = do
    eType <- checkExpr elt binds stmt
    unless (eType == TyNumber) $ stmtError stmt $
        "the array subscript expression for " ++ show id ++ " has type '"
        ++ show eType ++ "', when '" ++ show TyNumber ++ "' is expected"
    iType <- checkExpr (EVariable id) binds stmt
    case iType of
      TyArray sType -> do
        return sType
      oType -> do
        stmtError stmt $ show id ++ " has non-array type '" ++ show oType
            ++ "' in an array subscript expression"

-- Binary operator application
checkExpr (EBinary op exp exp') binds stmt = do
    ty <- checkExpr exp binds stmt
    ty' <- checkExpr exp' binds stmt
    unless (ty == ty') $ stmtError stmt $
        "the binary operator '" ++ show op ++ "' has operands of differing "
        ++ "types '" ++ show ty ++ "' and '" ++ show ty' ++ "'"
    case overloads (Right op) ty of
      Nothing -> do
        stmtError stmt $
            "the binary operator '" ++ show op ++ "' is applied to the "
            ++ "incompatible type '" ++ show ty ++ "'"
      Just ty'' -> do
        return ty''

-- Unary operator application
checkExpr (EUnary op exp) binds stmt = do
    ty <- checkExpr exp binds stmt
    case overloads (Left op) ty of
      Nothing -> do
        stmtError stmt $
            "the unary operator '" ++ show op ++ "' is applied to the "
            ++ "incompatible type '" ++ show ty ++ "'"
      Just ty'' -> do
        return ty''
    return ty

--------------------------------------------------------------------------------
-- Raises a failure condition in the Either monad with the given error message.
-- The error message is marked as a semantic error.
aliceError :: String -> Either String a
aliceError msg
  = Left $ "semantic error: " ++ msg

--------------------------------------------------------------------------------
-- Like aliceError, except the error message is also marked with the input
-- position recorded in the given Stmt instance.
stmtError :: Stmt -> String -> Either String a
stmtError stmt msg
  = Left $ "[" ++ show row ++ ":" ++ show col ++ "] semantic error: " ++ msg
  where (chr,row,col) = sPosn stmt

--------------------------------------------------------------------------------
-- True iff the given statement is a declaration.
isDecl :: Stmt -> Bool
isDecl stmt
  = case stmt of
        SFunDec{ }  -> True
        SSubDec{ }  -> True
        SVarDec{ }  -> True
        SArrDec{ }  -> True
        _           -> False

--------------------------------------------------------------------------------
-- True iff the given expression is in the form that may occur on the left-hand
-- side of an assignment.
isLValue :: Expr -> Bool
isLValue expr
  = case expr of
        EVariable{ }    -> True
        EArrElt{ }      -> True
        _               -> False

--------------------------------------------------------------------------------
-- Given a unary or binary operator symbol and the type of its operands, gives
-- the resulting type if such an overload is defined, or otherwise Nothing.
overloads :: Either UnOp BiOp -> Type -> Maybe Type
overloads (Left op) ty
  | op `elem` [UNeg, UNotB]
  = if ty `elem` [TyNumber]
    then Just ty else Nothing
  | op `elem` [UNot]
  = if ty `elem` [TyBoolean]
    then Just ty else Nothing
overloads (Right op) ty
  | op `elem` [BAdd, BSub, BMul, BDiv, BRem, BAndB, BOrB, BXOrB]
  = if ty `elem` [TyNumber]
    then Just ty else Nothing
  | op `elem` [BEqu, BNEq, BLT, BGT, BLE, BGE]
  = if ty `elem` [TyNumber, TyLetter, TySentence]
    then Just TyBoolean else Nothing
  | op `elem` [BAnd, BOr]
  = if ty `elem` [TyBoolean] then
    Just ty else Nothing
